/*******************************************************************************
 * Copyright (c) 2012 Cesar Yeep.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the BSD 3-Clause License
 * ("New BSD" or "BSD Simplified") which accompanies this distribution,
 * and is available at
 * http://opensource.org/licenses/BSD-3-Clause
 * 
 * Contributors:
 *     Cesar Yeep - initial API and implementation
 ******************************************************************************/
aspect CleanJavaStatement {

  // helper attribute to find the containing CJMethodDecl
	syn CJMethodDecl ASTNode.containingCJMethodDecl() = getParent() != null ? getParent().containingCJMethodDecl() : null;
	syn CJMethodDecl CJMethodDecl.containingCJMethodDecl() = this;
	//syn CJConstructorDecl CJConstructorDecl.containingCJMethodDecl() = this;
	
	//TODO: review attributes in this section
	eq CJMethodDecl.getSpecs().lookupVariable(String name) {
		SimpleSet set = parameterDeclaration(name);
		if (!set.isEmpty()) return set;
		// Delegate to other declarations in scope
		return lookupVariable(name);
	}

  // Unreachable Statements (see UnreachableStatements.jrag)

	eq CJStaticInitializer.getSpecs().reachable() = true;
	eq CJInstanceInitializer.getSpecs().reachable()  = true; 
	eq CJMethodDecl.getSpecs().reachable()        = true;
	eq CJConstructorDecl.getSpecs().reachable()   = true;


  // Pretty printer
	
	syn String SimpleConcurrentAssignment.printOp() = " := ";
	syn String SimpleConcurrentAssignmentByRef.printOp() = " @= ";

	public void SplittedDefinition.toString(StringBuffer s) {
		for(int i = 0; i < getNumAssignment(); i++) {
			if(i != 0){
				s.append(";");
				s.append(indent());
			}
			getAssignment(i).toString(s);
		}
	}
	
	public void SimpleConcurrentAssignment.toString(StringBuffer s) {
		for(int i = 0; i < getNumDest(); i++) {
			if(i != 0)
				s.append(", ");
			getDest(i).toString(s);
		}
		
		s.append(printOp());

		for(int i = 0; i < getNumSource(); i++) {
			if(i != 0)
				s.append(", ");
			getSource(i).toString(s);
		}
	}
	
	public void CondConcurrentAssignment.toString(StringBuffer s) {
		for(int i = 0; i < getNumPairs(); i++) {
			if(i != 0){
				s.append(indent());
				s.append("| ");
			}
			getPairs(i).toString(s);
		}
		if(hasElse()){
			s.append(indent());
			s.append("| otherwise -> ");
			s.append(getElse());
		}
			
	}
	
	public void SplittedDefinitionCondConcurrentAssignment.toString(StringBuffer s) {
		for(int i = 0; i < getNumConditionalAssignment(); i++) {
			if(i != 0){
				s.append("; ");
				s.append(indent());
			}
			getConditionalAssignment(i).toString(s);
		}		
	}
	
	public void ExprAndAbstractSimpleConcurrentAssignment.toString(StringBuffer s) {
		getCondition().toString(s);
		s.append(" -> ");
		getThen().toString(s);
	}
	
	public void Identity.toString(StringBuffer s){
		s.append(" I ");
	}
		
  // Type check
  
	/** Perform type checking in a simple concurrent assignment. */
	public void SimpleConcurrentAssignment.typeCheck() {
		//Check if equation is balanced
		if(getNumDest() != getNumSource()) {
			error("concurrent assignment is unbalanced");
		}
		else{
			ArrayList<String> variables = new ArrayList<String>();
			ArrayList<String> duplicates = new ArrayList<String>();
			for(int i = 0; i < getNumDest(); i++) {
				Expr dest = getDest(i);
				Expr source = getSource(i);
				
				//Check assignment compatiblity
				checkAssignmentCompatiblity(dest,source);
				
				//If node is not a CJResult get var decl name
				if(dest.isVariable()){
					String name = dest.varDecl().name();
					if(!variables.contains(name))
						variables.add(name);
					else
						if(!duplicates.contains(name))
							duplicates.add(name);
				}
				else if(dest.isCJResult()){
					if(!variables.contains("\\result"))
						variables.add("\\result");
					else
						if(!duplicates.contains("\\result"))
							duplicates.add("\\result");
				}
			}

			//Check if there are name duplicates
			if(duplicates.size() > 0)
				error("there are duplicates in the left-hand side of the equation: " + getVariableDuplicates(duplicates));
		}
	}
	
	/** Check assignment compatiblity for simple concurrent assignments. */
	public void SimpleConcurrentAssignment.checkAssignmentCompatiblity(Expr dest, Expr source){
		if(!dest.isVariable() && !dest.isCJResult())
			error(dest+" is not a variable");
		else if(!source.type().assignConversionTo(dest.type(), source) && !source.type().isUnknown())
			error("cannot assign " + dest + " of type " + dest.type().typeName() +
				" a value of type " + source.type().typeName());
		else if(dest.isCJResult() && containingCJMethodDecl() == null)
			error("incorrect use of \\result, \\result must be used within a method declaration");
	}
	
	/** Check assignment compatiblity for simple concurrent assignments by reference. */
	public void SimpleConcurrentAssignmentByRef.checkAssignmentCompatiblity(Expr dest, Expr source){
		if(!dest.isVariable() && !dest.isCJResult())
			error(dest+" is not a variable");
		else if(dest.type().isPrimitive())
			error("cannot use " + dest + " of primitive "+dest.type()+" type using referential semantics"); 
		else if(!source.type().assignConversionTo(dest.type(), source) && !source.type().isUnknown())
			error("cannot assign " + dest + " of type " + dest.type().typeName() +
				" a value of type " + source.type().typeName());
		else if(dest.isCJResult() && containingCJMethodDecl() == null)
			error("incorrect use of \\result, \\result must be used within a method declaration");
	}
		
	/** Get variable duplicate names in a simple concurrent assignemtn. */
	public String SimpleConcurrentAssignment.getVariableDuplicates(ArrayList<String> list)
	{
		String duplicates = "";
		Iterator it = list.iterator();
		while(it.hasNext()){
			duplicates += it.next();
			if(it.hasNext())
				duplicates += ", ";
		}
		return duplicates;
	}
	
	/** Type check creating a new SimpleConcurrentAssignment. */
	public void SplittedDefinition.typeCheck() {
		createSimpleConcurrentAssignmentList();
	}
	
	/** Merge lists of SimpleConcurrentAssignments into a single SimpleConcurrentAssignment. */
	public void SplittedDefinition.createSimpleConcurrentAssignmentList(){
		int referential = 0;
		List<Expr> leftHandExprList = new List<Expr>();
		List<Expr> rightHandExprList = new List<Expr>();
		//Iterate over a list of simple concurrent assignments
		for(int i = 0; i < getNumAssignment(); i++) {
				SimpleConcurrentAssignment simpleConcurrentAssignment = getAssignment(i);
				if(simpleConcurrentAssignment instanceof SimpleConcurrentAssignmentByRef)
					referential++;
				//Iterate over simple concurrent assignment destinations
				for(int j = 0; j < simpleConcurrentAssignment.getNumDest(); j++)
					leftHandExprList.add(simpleConcurrentAssignment.getDest(j));
				//Iterate over simple concurrent assignment sources
				for(int j = 0; j < simpleConcurrentAssignment.getNumSource(); j++)
					rightHandExprList.add(simpleConcurrentAssignment.getSource(j));	
		}
		if(referential > 0 && referential < getNumAssignment() )
			error("incorrect use of splitting definitions; you must use the same type of equality tests (e.g. referential semantics or value semantics)");
		
		if(referential > 0){
			SimpleConcurrentAssignmentByRef simpleConcurrentAssignmenByRef = new SimpleConcurrentAssignmentByRef(leftHandExprList,rightHandExprList);
			setAssignmentList(new List<SimpleConcurrentAssignment>().add(simpleConcurrentAssignmenByRef));
		}
		else{
			SimpleConcurrentAssignment simpleConcurrentAssignment = new  SimpleConcurrentAssignment(leftHandExprList,rightHandExprList);
			setAssignmentList(new List<SimpleConcurrentAssignment>().add(simpleConcurrentAssignment));
		}
	}
}