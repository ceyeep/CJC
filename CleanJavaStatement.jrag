/*******************************************************************************
 * Copyright (c) 2012 Cesar Yeep.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the BSD 3-Clause License
 * ("New BSD" or "BSD Simplified") which accompanies this distribution,
 * and is available at
 * http://opensource.org/licenses/BSD-3-Clause
 * 
 * Contributors:
 *     Cesar Yeep - initial API and implementation
 ******************************************************************************/
aspect CleanJavaStatement {

  // helper attribute to find the containing CJMethodDecl
	syn CJMethodDecl ASTNode.containingCJMethodDecl() = getParent() != null ? getParent().containingCJMethodDecl() : null;
	syn CJMethodDecl CJMethodDecl.containingCJMethodDecl() = this;
	//syn CJConstructorDecl CJConstructorDecl.containingCJMethodDecl() = this;
	
	eq CJMethodDecl.getSpecs().lookupVariable(String name) {
		SimpleSet set = parameterDeclaration(name);
		if (!set.isEmpty()) return set;
		// Delegate to other declarations in scope
		return lookupVariable(name);
	}
	

  // Unreachable Statements (see UnreachableStatements.jrag)

	eq CJStaticInitializer.getSpecs().reachable() = true;
	eq CJInstanceInitializer.getSpecs().reachable()  = true; 
	eq CJMethodDecl.getSpecs().reachable()        = true;
	eq CJConstructorDecl.getSpecs().reachable()   = true;


  // Pretty printer
	
	syn String SimpleConcurrentAssignment.printOp() = " := ";
	syn String SimpleConcurrentAssignmentByRef.printOp() = " @= ";
		
	public void SimpleConcurrentAssignment.toString(StringBuffer s) {
		if(getNumDest() > 0) {
			for(int i = 0; i < getNumDest(); i++) {
				if(i != 0)
					s.append(", ");
				getDest(i).toString(s);
			}
		}
		s.append(printOp());
		if(getNumSource() > 0) {
			for(int i = 0; i < getNumSource(); i++) {
				if(i != 0)
					s.append(", ");
				getSource(i).toString(s);
			}
		}
	}
	
	public void CondConcurrentAssignment.toString(StringBuffer s) {
		if(getNumPairs() > 0) {
			for(int i = 0; i < getNumPairs(); i++) {
				if(i != 0)
				{
					s.append(indent());
					s.append("| ");
				}
				getPairs(i).toString(s);
			}
		}
		
	}
	
	public void ExprAndAbstractSimpleConcurrentAssignment.toString(StringBuffer s) {
		getCondition().toString(s);
		s.append(" -> ");
		getThen().toString(s);
	}
	
	public void Identity.toString(StringBuffer s){
		s.append(" I ");
	}
	
		
  // Type check
	
	/** Perform type checking in a simple concurrent assignemtn. */
	public void SimpleConcurrentAssignment.typeCheck() {
		//Check if equation is balanced
		if(getNumDest() != getNumSource()) {
			error("concurrent assignment is unbalanced");
		}
		else{
			ArrayList<String> variables = new ArrayList<String>();
			ArrayList<String> duplicates = new ArrayList<String>();
			for(int i = 0; i < getNumDest(); i++) {
				Expr dest = getDest(i);
				Expr source = getSource(i);
				
				//Check assignment compatiblity
				checkAssignmentCompatiblity(dest,source);
				
				//If node is not a CJResult get var decl name
				if(dest.isVariable()){
					String name = dest.varDecl().name();
					if(!variables.contains(name))
						variables.add(name);
					else
						if(!duplicates.contains(name))
							duplicates.add(name);
				}
				else if(dest.isCJResult()){
					if(!variables.contains("\\result"))
						variables.add("\\result");
					else
						if(!duplicates.contains("\\result"))
							duplicates.add("\\result");
				}
			}

			//Check if there are name duplicates
			if(duplicates.size() > 0)
				error("there are duplicates in the left-hand side of the equation: " + getVariableDuplicates(duplicates));
			
		}
	}
	
	/** Check assignment compatiblity for simple concurrent assignments. */
	public void SimpleConcurrentAssignment.checkAssignmentCompatiblity(Expr dest, Expr source){
		if(!dest.isVariable() && !dest.isCJResult())
			error(dest+" is not a variable");
		else if(!source.type().assignConversionTo(dest.type(), source) && !source.type().isUnknown())
			error("cannot assign " + dest + " of type " + dest.type().typeName() +
				" a value of type " + source.type().typeName());
		else if(dest.isCJResult() && containingCJMethodDecl() == null)
			error("incorrect use of \\result, \\result must be used within a method declaration");
	}
	
	/** Check assignment compatiblity for simple concurrent assignments by reference. */
	public void SimpleConcurrentAssignmentByRef.checkAssignmentCompatiblity(Expr dest, Expr source){
		if(!dest.isVariable() && !dest.isCJResult())
			error(dest+" is not a variable");
		else if(dest.type().isPrimitive())
			error("cannot use " + dest + " of primitive "+dest.type()+" type using referential semantics"); 
		else if(!source.type().assignConversionTo(dest.type(), source) && !source.type().isUnknown())
			error("cannot assign " + dest + " of type " + dest.type().typeName() +
				" a value of type " + source.type().typeName());
		else if(dest.isCJResult() && containingCJMethodDecl() == null)
			error("incorrect use of \\result, \\result must be used within a method declaration");
			
	}
		
	/** Get variable duplicate names in a simple concurrent assignemtn. */
	public String SimpleConcurrentAssignment.getVariableDuplicates(ArrayList<String> list)
	{
		String duplicates = "";
		Iterator it = list.iterator();
		while(it.hasNext()){
			duplicates += it.next();
			if(it.hasNext())
				duplicates += ", ";
		}
		return duplicates;
	}
		
}